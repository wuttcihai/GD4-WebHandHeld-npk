import { Injectable, NgZone } from '@angular/core';
import { VanillaFrameworkOverrides } from 'ag-grid-community';
import { AngularFrameworkEventListenerService } from './angularFrameworkEventListenerService';
import * as i0 from "@angular/core";
export class AngularFrameworkOverrides extends VanillaFrameworkOverrides {
    constructor(_ngZone) {
        super('angular');
        this._ngZone = _ngZone;
        // Flag used to control Zone behaviour when running tests as many test features rely on Zone.
        this.isRunningWithinTestZone = false;
        // Make all events run outside Angular as they often trigger the setup of event listeners
        // By having the event listeners outside Angular we can avoid triggering change detection
        // This also means that if a user calls an AG Grid API method from within their component
        // the internal side effects will not trigger change detection. Without this the events would
        // run inside Angular and trigger change detection as the source of the event was within the angular zone.
        this.wrapIncoming = (callback, source) => this.runOutside(callback, source);
        /**
         * Make sure that any code that is executed outside of AG Grid is running within the Angular zone.
         * This means users can update templates and use binding without having to do anything extra.
         */
        this.wrapOutgoing = (callback) => this.runInsideAngular(callback);
        this.isRunningWithinTestZone =
            window?.AG_GRID_UNDER_TEST ?? !!window?.Zone?.AsyncTestZoneSpec;
        if (!this._ngZone) {
            this.runOutside = (callback) => callback();
        }
        else if (this.isRunningWithinTestZone) {
            this.runOutside = (callback, source) => {
                if (source === 'resize-observer' || source === 'popupPositioning') {
                    // ensure resize observer callbacks are run outside of Angular even under test due to Jest not supporting ResizeObserver
                    // which means it just loops continuously with a setTimeout with no way to flush the queue or have fixture.whenStable() resolve.
                    return this._ngZone.runOutsideAngular(callback);
                }
                // When under test run inside Angular so that tests can use fixture.whenStable() to wait for async operations to complete.
                return callback();
            };
        }
        else {
            this.runOutside = (callback) => this._ngZone.runOutsideAngular(callback);
        }
    }
    /**
     * The shouldWrapOutgoing property is used to determine if events should be run outside of Angular or not.
     * If an event handler is registered outside of Angular then we should not wrap the event handler
     * with runInsideAngular() as the user may not have wanted this.
     * This is also used to not wrap internal event listeners that are registered with RowNodes and Columns.
     */
    get shouldWrapOutgoing() {
        return this._ngZone && NgZone.isInAngularZone();
    }
    createLocalEventListenerWrapper(existingFrameworkEventListenerService, localEventService) {
        if (this.shouldWrapOutgoing) {
            return (existingFrameworkEventListenerService ??
                (() => {
                    localEventService.setFrameworkOverrides(this);
                    return new AngularFrameworkEventListenerService(this);
                })());
        }
        return undefined;
    }
    createGlobalEventListenerWrapper() {
        return new AngularFrameworkEventListenerService(this);
    }
    isFrameworkComponent(comp) {
        if (!comp) {
            return false;
        }
        const prototype = comp.prototype;
        const isAngularComp = prototype && 'agInit' in prototype;
        return isAngularComp;
    }
    runInsideAngular(callback) {
        // Check for _ngZone existence as it is not present when Zoneless
        return this._ngZone ? this._ngZone.run(callback) : callback();
    }
    runOutsideAngular(callback, source) {
        return this.runOutside(callback, source);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: AngularFrameworkOverrides, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: AngularFrameworkOverrides }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: AngularFrameworkOverrides, decorators: [{
            type: Injectable
        }], ctorParameters: () => [{ type: i0.NgZone }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhckZyYW1ld29ya092ZXJyaWRlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL2FnLWdyaWQtYW5ndWxhci9zcmMvbGliL2FuZ3VsYXJGcmFtZXdvcmtPdmVycmlkZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFPbkQsT0FBTyxFQUFFLHlCQUF5QixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFOUQsT0FBTyxFQUFFLG9DQUFvQyxFQUFFLE1BQU0sd0NBQXdDLENBQUM7O0FBRzlGLE1BQU0sT0FBTyx5QkFBMEIsU0FBUSx5QkFBeUI7SUFNcEUsWUFBb0IsT0FBZTtRQUMvQixLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7UUFERCxZQUFPLEdBQVAsT0FBTyxDQUFRO1FBTG5DLDZGQUE2RjtRQUNyRiw0QkFBdUIsR0FBWSxLQUFLLENBQUM7UUEyQmpELHlGQUF5RjtRQUN6Rix5RkFBeUY7UUFDekYseUZBQXlGO1FBQ3pGLDZGQUE2RjtRQUM3RiwwR0FBMEc7UUFDakcsaUJBQVksR0FBMkUsQ0FDNUYsUUFBUSxFQUNSLE1BQU0sRUFDUixFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFZdkM7OztXQUdHO1FBQ00saUJBQVksR0FBZ0MsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQTVDL0YsSUFBSSxDQUFDLHVCQUF1QjtZQUN2QixNQUFjLEVBQUUsa0JBQWtCLElBQUksQ0FBQyxDQUFFLE1BQWMsRUFBRSxJQUFJLEVBQUUsaUJBQWlCLENBQUM7UUFFdEYsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDZixJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUM5QzthQUFNLElBQUksSUFBSSxDQUFDLHVCQUF1QixFQUFFO1lBQ3JDLElBQUksQ0FBQyxVQUFVLEdBQUcsQ0FBQyxRQUFRLEVBQUUsTUFBTSxFQUFFLEVBQUU7Z0JBQ25DLElBQUksTUFBTSxLQUFLLGlCQUFpQixJQUFJLE1BQU0sS0FBSyxrQkFBa0IsRUFBRTtvQkFDL0Qsd0hBQXdIO29CQUN4SCxnSUFBZ0k7b0JBQ2hJLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztpQkFDbkQ7Z0JBQ0QsMEhBQTBIO2dCQUMxSCxPQUFPLFFBQVEsRUFBRSxDQUFDO1lBQ3RCLENBQUMsQ0FBQztTQUNMO2FBQU07WUFDSCxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzVFO0lBQ0wsQ0FBQztJQVlEOzs7OztPQUtHO0lBQ0gsSUFBVyxrQkFBa0I7UUFDekIsT0FBTyxJQUFJLENBQUMsT0FBTyxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUNwRCxDQUFDO0lBUU0sK0JBQStCLENBQ2xDLHFDQUEyRixFQUMzRixpQkFBeUM7UUFFekMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEVBQUU7WUFDekIsT0FBTyxDQUNILHFDQUFxQztnQkFDckMsQ0FBQyxHQUFHLEVBQUU7b0JBQ0YsaUJBQWlCLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzlDLE9BQU8sSUFBSSxvQ0FBb0MsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDMUQsQ0FBQyxDQUFDLEVBQUUsQ0FDUCxDQUFDO1NBQ0w7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNyQixDQUFDO0lBRU0sZ0NBQWdDO1FBQ25DLE9BQU8sSUFBSSxvQ0FBb0MsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxRCxDQUFDO0lBRVEsb0JBQW9CLENBQUMsSUFBUztRQUNuQyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ1AsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQ2pDLE1BQU0sYUFBYSxHQUFHLFNBQVMsSUFBSSxRQUFRLElBQUksU0FBUyxDQUFDO1FBQ3pELE9BQU8sYUFBYSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxnQkFBZ0IsQ0FBSSxRQUFpQjtRQUNqQyxpRUFBaUU7UUFDakUsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbEUsQ0FBQztJQUVELGlCQUFpQixDQUFJLFFBQWlCLEVBQUUsTUFBeUM7UUFDN0UsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUM3QyxDQUFDOytHQTVGUSx5QkFBeUI7bUhBQXpCLHlCQUF5Qjs7NEZBQXpCLHlCQUF5QjtrQkFEckMsVUFBVSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgdHlwZSB7XG4gICAgRnJhbWV3b3JrT3ZlcnJpZGVzSW5jb21pbmdTb3VyY2UsXG4gICAgSUZyYW1ld29ya0V2ZW50TGlzdGVuZXJTZXJ2aWNlLFxuICAgIExvY2FsRXZlbnRTZXJ2aWNlLFxufSBmcm9tICdhZy1ncmlkLWNvbW11bml0eSc7XG5pbXBvcnQgeyBWYW5pbGxhRnJhbWV3b3JrT3ZlcnJpZGVzIH0gZnJvbSAnYWctZ3JpZC1jb21tdW5pdHknO1xuXG5pbXBvcnQgeyBBbmd1bGFyRnJhbWV3b3JrRXZlbnRMaXN0ZW5lclNlcnZpY2UgfSBmcm9tICcuL2FuZ3VsYXJGcmFtZXdvcmtFdmVudExpc3RlbmVyU2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBbmd1bGFyRnJhbWV3b3JrT3ZlcnJpZGVzIGV4dGVuZHMgVmFuaWxsYUZyYW1ld29ya092ZXJyaWRlcyB7XG4gICAgLy8gRmxhZyB1c2VkIHRvIGNvbnRyb2wgWm9uZSBiZWhhdmlvdXIgd2hlbiBydW5uaW5nIHRlc3RzIGFzIG1hbnkgdGVzdCBmZWF0dXJlcyByZWx5IG9uIFpvbmUuXG4gICAgcHJpdmF0ZSBpc1J1bm5pbmdXaXRoaW5UZXN0Wm9uZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBydW5PdXRzaWRlOiA8VD4oY2FsbGJhY2s6ICgpID0+IFQsIHNvdXJjZT86IEZyYW1ld29ya092ZXJyaWRlc0luY29taW5nU291cmNlKSA9PiBUO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIoJ2FuZ3VsYXInKTtcblxuICAgICAgICB0aGlzLmlzUnVubmluZ1dpdGhpblRlc3Rab25lID1cbiAgICAgICAgICAgICh3aW5kb3cgYXMgYW55KT8uQUdfR1JJRF9VTkRFUl9URVNUID8/ICEhKHdpbmRvdyBhcyBhbnkpPy5ab25lPy5Bc3luY1Rlc3Rab25lU3BlYztcblxuICAgICAgICBpZiAoIXRoaXMuX25nWm9uZSkge1xuICAgICAgICAgICAgdGhpcy5ydW5PdXRzaWRlID0gKGNhbGxiYWNrKSA9PiBjYWxsYmFjaygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNSdW5uaW5nV2l0aGluVGVzdFpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMucnVuT3V0c2lkZSA9IChjYWxsYmFjaywgc291cmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gJ3Jlc2l6ZS1vYnNlcnZlcicgfHwgc291cmNlID09PSAncG9wdXBQb3NpdGlvbmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHJlc2l6ZSBvYnNlcnZlciBjYWxsYmFja3MgYXJlIHJ1biBvdXRzaWRlIG9mIEFuZ3VsYXIgZXZlbiB1bmRlciB0ZXN0IGR1ZSB0byBKZXN0IG5vdCBzdXBwb3J0aW5nIFJlc2l6ZU9ic2VydmVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IGp1c3QgbG9vcHMgY29udGludW91c2x5IHdpdGggYSBzZXRUaW1lb3V0IHdpdGggbm8gd2F5IHRvIGZsdXNoIHRoZSBxdWV1ZSBvciBoYXZlIGZpeHR1cmUud2hlblN0YWJsZSgpIHJlc29sdmUuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHVuZGVyIHRlc3QgcnVuIGluc2lkZSBBbmd1bGFyIHNvIHRoYXQgdGVzdHMgY2FuIHVzZSBmaXh0dXJlLndoZW5TdGFibGUoKSB0byB3YWl0IGZvciBhc3luYyBvcGVyYXRpb25zIHRvIGNvbXBsZXRlLlxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucnVuT3V0c2lkZSA9IChjYWxsYmFjaykgPT4gdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2UgYWxsIGV2ZW50cyBydW4gb3V0c2lkZSBBbmd1bGFyIGFzIHRoZXkgb2Z0ZW4gdHJpZ2dlciB0aGUgc2V0dXAgb2YgZXZlbnQgbGlzdGVuZXJzXG4gICAgLy8gQnkgaGF2aW5nIHRoZSBldmVudCBsaXN0ZW5lcnMgb3V0c2lkZSBBbmd1bGFyIHdlIGNhbiBhdm9pZCB0cmlnZ2VyaW5nIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAvLyBUaGlzIGFsc28gbWVhbnMgdGhhdCBpZiBhIHVzZXIgY2FsbHMgYW4gQUcgR3JpZCBBUEkgbWV0aG9kIGZyb20gd2l0aGluIHRoZWlyIGNvbXBvbmVudFxuICAgIC8vIHRoZSBpbnRlcm5hbCBzaWRlIGVmZmVjdHMgd2lsbCBub3QgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uLiBXaXRob3V0IHRoaXMgdGhlIGV2ZW50cyB3b3VsZFxuICAgIC8vIHJ1biBpbnNpZGUgQW5ndWxhciBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIGFzIHRoZSBzb3VyY2Ugb2YgdGhlIGV2ZW50IHdhcyB3aXRoaW4gdGhlIGFuZ3VsYXIgem9uZS5cbiAgICBvdmVycmlkZSB3cmFwSW5jb21pbmc6IDxUPihjYWxsYmFjazogKCkgPT4gVCwgc291cmNlPzogRnJhbWV3b3JrT3ZlcnJpZGVzSW5jb21pbmdTb3VyY2UpID0+IFQgPSAoXG4gICAgICAgIGNhbGxiYWNrLFxuICAgICAgICBzb3VyY2VcbiAgICApID0+IHRoaXMucnVuT3V0c2lkZShjYWxsYmFjaywgc291cmNlKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaG91bGRXcmFwT3V0Z29pbmcgcHJvcGVydHkgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgZXZlbnRzIHNob3VsZCBiZSBydW4gb3V0c2lkZSBvZiBBbmd1bGFyIG9yIG5vdC5cbiAgICAgKiBJZiBhbiBldmVudCBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgb3V0c2lkZSBvZiBBbmd1bGFyIHRoZW4gd2Ugc2hvdWxkIG5vdCB3cmFwIHRoZSBldmVudCBoYW5kbGVyXG4gICAgICogd2l0aCBydW5JbnNpZGVBbmd1bGFyKCkgYXMgdGhlIHVzZXIgbWF5IG5vdCBoYXZlIHdhbnRlZCB0aGlzLlxuICAgICAqIFRoaXMgaXMgYWxzbyB1c2VkIHRvIG5vdCB3cmFwIGludGVybmFsIGV2ZW50IGxpc3RlbmVycyB0aGF0IGFyZSByZWdpc3RlcmVkIHdpdGggUm93Tm9kZXMgYW5kIENvbHVtbnMuXG4gICAgICovXG4gICAgcHVibGljIGdldCBzaG91bGRXcmFwT3V0Z29pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZ1pvbmUgJiYgTmdab25lLmlzSW5Bbmd1bGFyWm9uZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IGFueSBjb2RlIHRoYXQgaXMgZXhlY3V0ZWQgb3V0c2lkZSBvZiBBRyBHcmlkIGlzIHJ1bm5pbmcgd2l0aGluIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICogVGhpcyBtZWFucyB1c2VycyBjYW4gdXBkYXRlIHRlbXBsYXRlcyBhbmQgdXNlIGJpbmRpbmcgd2l0aG91dCBoYXZpbmcgdG8gZG8gYW55dGhpbmcgZXh0cmEuXG4gICAgICovXG4gICAgb3ZlcnJpZGUgd3JhcE91dGdvaW5nOiA8VD4oY2FsbGJhY2s6ICgpID0+IFQpID0+IFQgPSAoY2FsbGJhY2spID0+IHRoaXMucnVuSW5zaWRlQW5ndWxhcihjYWxsYmFjayk7XG5cbiAgICBwdWJsaWMgY3JlYXRlTG9jYWxFdmVudExpc3RlbmVyV3JhcHBlcihcbiAgICAgICAgZXhpc3RpbmdGcmFtZXdvcmtFdmVudExpc3RlbmVyU2VydmljZTogSUZyYW1ld29ya0V2ZW50TGlzdGVuZXJTZXJ2aWNlPGFueSwgYW55PiB8IHVuZGVmaW5lZCxcbiAgICAgICAgbG9jYWxFdmVudFNlcnZpY2U6IExvY2FsRXZlbnRTZXJ2aWNlPGFueT5cbiAgICApOiBJRnJhbWV3b3JrRXZlbnRMaXN0ZW5lclNlcnZpY2U8YW55LCBhbnk+IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkV3JhcE91dGdvaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nRnJhbWV3b3JrRXZlbnRMaXN0ZW5lclNlcnZpY2UgPz9cbiAgICAgICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbEV2ZW50U2VydmljZS5zZXRGcmFtZXdvcmtPdmVycmlkZXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQW5ndWxhckZyYW1ld29ya0V2ZW50TGlzdGVuZXJTZXJ2aWNlKHRoaXMpO1xuICAgICAgICAgICAgICAgIH0pKClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVHbG9iYWxFdmVudExpc3RlbmVyV3JhcHBlcigpOiBJRnJhbWV3b3JrRXZlbnRMaXN0ZW5lclNlcnZpY2U8YW55LCBhbnk+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmd1bGFyRnJhbWV3b3JrRXZlbnRMaXN0ZW5lclNlcnZpY2UodGhpcyk7XG4gICAgfVxuXG4gICAgb3ZlcnJpZGUgaXNGcmFtZXdvcmtDb21wb25lbnQoY29tcDogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3RvdHlwZSA9IGNvbXAucHJvdG90eXBlO1xuICAgICAgICBjb25zdCBpc0FuZ3VsYXJDb21wID0gcHJvdG90eXBlICYmICdhZ0luaXQnIGluIHByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGlzQW5ndWxhckNvbXA7XG4gICAgfVxuXG4gICAgcnVuSW5zaWRlQW5ndWxhcjxUPihjYWxsYmFjazogKCkgPT4gVCk6IFQge1xuICAgICAgICAvLyBDaGVjayBmb3IgX25nWm9uZSBleGlzdGVuY2UgYXMgaXQgaXMgbm90IHByZXNlbnQgd2hlbiBab25lbGVzc1xuICAgICAgICByZXR1cm4gdGhpcy5fbmdab25lID8gdGhpcy5fbmdab25lLnJ1bihjYWxsYmFjaykgOiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIHJ1bk91dHNpZGVBbmd1bGFyPFQ+KGNhbGxiYWNrOiAoKSA9PiBULCBzb3VyY2U/OiBGcmFtZXdvcmtPdmVycmlkZXNJbmNvbWluZ1NvdXJjZSk6IFQge1xuICAgICAgICByZXR1cm4gdGhpcy5ydW5PdXRzaWRlKGNhbGxiYWNrLCBzb3VyY2UpO1xuICAgIH1cbn1cbiJdfQ==